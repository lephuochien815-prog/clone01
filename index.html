<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Particles</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Montserrat:wght@300;400;800&display=swap" rel="stylesheet">

    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            font-family: 'Montserrat', sans-serif; user-select: none;
        }
        #background-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
            background: radial-gradient(circle at center, #9c4b75 0%, #5e2240 45%, #1f0814 100%);
        }
        #noise-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
            opacity: 0.04; pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 2; }
        
        #visualizer-canvas {
            position: absolute; 
            bottom: 25px; 
            left: 50%; 
            transform: translateX(-50%);
            width: 40%; 
            height: 60px; 
            z-index: 15; 
            pointer-events: none; 
            opacity: 0.8; 
        }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 50px 0 30px 0;
        }
        h1 { 
            color: #ffffff; font-family: 'Montserrat', sans-serif; font-size: 30px; font-weight: 800; 
            text-transform: uppercase; letter-spacing: 5px; margin: 0; 
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.6); opacity: 0; 
            animation: fadeIn 3s ease-out forwards 1s;
        }
        .hide-title { opacity: 0 !important; }
        .guide-container { margin-bottom: 110px; text-align: center; opacity: 0.8; transition: opacity 0.3s; }
        .guide-text { 
            color: #ffcae5; font-size: 14px; font-weight: 300; font-style: italic; 
            text-shadow: 0 0 5px rgba(255, 105, 180, 0.5);
        }
        .highlight { color: #ffffff; font-weight: 600; text-decoration: underline decoration-pink; }

        #webcam-wrapper {
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px;
            border-radius: 8px; overflow: hidden; z-index: 50; background: #000;
            border: 1px solid rgba(255, 158, 205, 0.3); opacity: 0.5; transition: opacity 0.3s;
        }
        #webcam-wrapper:hover { opacity: 1; }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        #status-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(82, 37, 56, 0.8);
            padding: 2px 0; color: #ffcae5; font-size: 10px; text-align: center; z-index: 60;
        }
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0510; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s ease;
        }
        .loader-text { color: #ff9ecd; font-family: 'Great Vibes', cursive; margin-top: 20px; font-size: 30px; }
        .spinner {
            width: 30px; height: 30px; border: 2px solid rgba(255, 158, 205, 0.2); 
            border-radius: 50%; border-top-color: #ff9ecd; animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://unpkg.com/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="loading-screen"><div class="spinner"></div><div class="loader-text">Loading...</div></div>
    <div id="background-layer"></div><div id="noise-overlay"></div><div id="canvas-container"></div>
    <canvas id="visualizer-canvas"></canvas>
    <div id="ui-layer">
        <h1 id="main-title">MAGIC PARTICLES</h1>
        <div class="guide-container"><span class="guide-text" id="guide-text">ƒêang chu·∫©n b·ªã...</span></div>
    </div>
    <div id="webcam-wrapper"><video id="webcam" autoplay playsinline muted></video><div id="status-bar">Init...</div></div>
    
    <audio id="audio-bg" src="./audio.mp3" loop preload="metadata"></audio>
    <audio id="audio-letter" src="./audio2.mp3" loop preload="metadata"></audio>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // ========== T·ªêI ∆ØU C·∫§U H√åNH ==========
        const CONFIG = {
            maxCount: 8000,      // GI·∫¢M t·ª´ 20000 xu·ªëng 8000 - c·∫£i thi·ªán FPS ƒë√°ng k·ªÉ
            particleSize: 0.08,   
            spread: 100,
            fadeSpeed: 2.0, 
            slideSpeed: 15.0, 
            slideGap: 40,     
            smoothFactor: 0.12, 
            gestureThreshold: 8,  // GI·∫¢M ƒë·ªÉ nh·∫°y h∆°n
            heartThreshold: 0.15,
            sparkleCount: 80      // GI·∫¢M t·ª´ 150 xu·ªëng 80
        };

        const IMG_FOX = './target.png'; 
        const IMG_PEN = './target2.png'; 
        const IMG_LETTER = './mess.png'; 
        const IMG_PHOTO_SINGLE = './photo.png';
        const SLIDE_IMAGES = ['./image/1.png', './image/2.png', './image/3.png', './image/4.png', './image/5.png', './image/6.png'];

        // ========== BI·∫æN T·ªêI ∆ØU ==========
        let scene, camera, renderer, composer, clock, bloomPass;
        let mainGroup, instancedMesh, messageMesh, singlePhotoMesh, slideshowGroup; 
        let glitterSystem, starSystem, whiteStarSystem, sparkleSystem; 
        let sparkleIndices = []; 
        let auraRingSystem; 
        const AURA_COUNT = 150; // GI·∫¢M t·ª´ 300 xu·ªëng 150

        let audioContext, audioAnalyser, audioSource, audioDataArray;
        let isAudioSetup = false;
        let visualizerCanvas, visualizerCtx;

        let slides = []; 
        let totalSlideWidth = 0; 
        let pCurrent, pTarget, pScatter; 
        let count = 0;
        let dummy = new THREE.Object3D();
        const _tempColor = new THREE.Color(); 
        const _targetColor = new THREE.Color(0xff69b4);
        const _zeroVec = new THREE.Vector3(0, 0, 0);

        let handLandmarker, video; 
        let isFoxLoaded = false, isPenLoaded = false;
        let appState = 'FOX'; 
        let interactionLock = 0; 
        let lastActionTime = 0; 
        let isLoadingDelay = false; 
        let loadingDelayTime = 0;
        let handParallax = { x: 0, y: 0 }; 
        let smoothedParallax = { x: 0, y: 0 }; 
        let imagesData = { 
            1: { data: null, width: 0, height: 0 }, 
            2: { data: null, width: 0, height: 0 } 
        };
        let currentBloomStrength = 0; 
        let currentOpacity = 1.0;
        let animLetter = { scale: 0, y: -50, pScale: 1, pY: 0 };
        let animSlide = { opacity: 0 }; 
        let animSinglePhoto = { opacity: 0, scale: 0 };
        let gestureBuffer = { pinch: 0, open: 0, heart: 0, fist: 0 };
        let lastVideoTime = -1;
        
        // ========== T·ªêI ∆ØU ANIMATION ==========
        let frameCount = 0;
        let lastFpsTime = 0;
        let currentFps = 60;
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;
        let lastFrameTime = performance.now();
        let isAnimating = false;

        // ========== LOADING T·ªêI ∆ØU ==========
        let loadingAssets = 0;
        let totalAssets = 0;

        // ========== KH·ªûI T·∫†O NHANH ==========
        async function init() {
            console.time('Total Init Time');
            
            // Hi·ªÉn th·ªã UI ngay l·∫≠p t·ª©c
            updateStatus("Starting...");
            
            // Kh·ªüi t·∫°o Three.js tr∆∞·ªõc (kh√¥ng ch·ªù)
            initThree();
            
            // Load assets song song
            const loadPromises = [];
            
            // Load ·∫£nh tr∆∞·ªõc
            loadPromises.push(loadImage(IMG_FOX, 1));
            loadPromises.push(loadImage(IMG_PEN, 2));
            
            // Setup basic scene
            setupPostProcessing();
            setupMessageMesh(); 
            setupSinglePhoto(); 
            setupSlideshow(); 
            
            // Gi·∫£m ƒë·ªô ph·ª©c t·∫°p particle system
            initInstancedMesh(CONFIG.maxCount); 
            setupSparkles(); 
            setupGlitter(); 
            setupFloatingStars(); 
            setupWhiteStars();
            setupAuraRing();
            
            // Kh·ªüi t·∫°o visualizer
            initVisualizer2D();
            
            // Load MediaPipe sau
            Promise.all(loadPromises)
                .then(() => {
                    useImageData(1);
                    updateStatus("Loading AI...");
                    
                    // B·∫Øt ƒë·∫ßu animation loop ngay
                    isAnimating = true;
                    animate();
                    
                    // Load MediaPipe trong background
                    initMediaPipe().then(() => {
                        hideLoading();
                        setupEvents();
                        updateStatus("Ready!");
                    });
                })
                .catch(err => {
                    console.error("Error loading assets", err);
                    updateStatus("Error - Please refresh");
                    hideLoading();
                });

            console.timeEnd('Total Init Time');
        }

        function hideLoading() {
            const el = document.getElementById('loading-screen');
            if(el) {
                el.style.opacity = '0';
                setTimeout(() => {
                    if (el.parentNode) el.parentNode.removeChild(el);
                }, 500);
            }
        }

        // ========== THREE.JS T·ªêI ∆ØU ==========
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            
            // T·∫Øt fog ƒë·ªÉ tƒÉng performance
            // scene.fog = new THREE.FogExp2(0x5e2240, 0.002);
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 70;
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                powerPreference: "high-performance",
                alpha: true,
                precision: 'mediump' // Gi·∫£m precision ƒë·ªÉ tƒÉng performance
            });
            
            // T·ªëi ∆∞u renderer
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1); // C·ªë ƒë·ªãnh pixel ratio ƒë·ªÉ tƒÉng FPS
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            container.appendChild(renderer.domElement);
            clock = new THREE.Clock();
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            
            // T·ªëi ∆∞u bloom pass
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth/8, window.innerHeight/8), // Gi·∫£m resolution
                1.5, 0.8, 0.8
            );
            bloomPass.threshold = 0; 
            bloomPass.strength = 0; 
            bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer); 
            composer.addPass(renderScene); 
            composer.addPass(bloomPass);
        }

        // ========== PARTICLE SYSTEM T·ªêI ∆ØU ==========
        function initInstancedMesh(cnt) {
            // S·ª≠ d·ª•ng geometry ƒë∆°n gi·∫£n h∆°n
            const geo = new THREE.SphereGeometry(CONFIG.particleSize, 4, 4); // Thay v√¨ Icosahedron
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 1, 
                depthWrite: false 
            });
            
            instancedMesh = new THREE.InstancedMesh(geo, mat, cnt);
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            
            // Pre-allocate arrays
            pCurrent = new Float32Array(cnt * 3);
            pTarget = new Float32Array(cnt * 3);
            pScatter = new Float32Array(cnt * 3);
            
            mainGroup = new THREE.Group(); 
            mainGroup.add(instancedMesh); 
            scene.add(mainGroup);
        }

        function loadImage(url, id) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.decoding = 'async'; // T·ªëi ∆∞u decode ·∫£nh
                img.loading = 'eager';
                
                img.onload = () => {
                    // Gi·∫£m k√≠ch th∆∞·ªõc ·∫£nh x·ª≠ l√Ω
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    
                    // Gi·∫£m maxSize ƒë·ªÉ x·ª≠ l√Ω nhanh h∆°n
                    const maxSize = 200; // GI·∫¢M t·ª´ 400 xu·ªëng 200
                    const aspect = img.width / img.height;
                    const h = Math.min(maxSize, img.height);
                    const w = Math.floor(h * aspect);
                    
                    canvas.width = w;
                    canvas.height = h;
                    
                    // Draw v·ªõi ch·∫•t l∆∞·ª£ng th·∫•p h∆°n
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(img, 0, 0, w, h);
                    
                    // Ch·ªâ l·∫•y d·ªØ li·ªáu khi c·∫ßn
                    const imageData = ctx.getImageData(0, 0, w, h);
                    imagesData[id].data = imageData.data;
                    imagesData[id].width = w;
                    imagesData[id].height = h;
                    
                    if(id === 1) isFoxLoaded = true;
                    else isPenLoaded = true;
                    
                    resolve();
                };
                
                img.onerror = () => {
                    console.error(`Failed to load image: ${url}`);
                    reject(new Error(`Failed to load image: ${url}`));
                };
                
                img.src = url;
            });
        }

        function useImageData(id) {
            const data = imagesData[id].data;
            const w = imagesData[id].width;
            const h = imagesData[id].height;
            
            if(!data) return;
            
            // T·ªëi ∆∞u l·∫•y valid indices
            const validIndices = [];
            const dataLength = data.length;
            
            // TƒÉng step ƒë·ªÉ gi·∫£m s·ªë l∆∞·ª£ng particles
            const step = 4;
            for (let i = 0; i < dataLength; i += step * 4) {
                if (data[i + 3] > 50) {
                    validIndices.push(i);
                }
            }
            
            const activeCount = Math.min(CONFIG.maxCount, validIndices.length);
            count = activeCount;
            instancedMesh.count = count;
            
            const spread = 60;
            const imgAspect = h / w;
            
            sparkleIndices = [];
            const sparkleTotal = Math.min(CONFIG.sparkleCount, activeCount);
            
            // Pre-calculate random indices
            for(let k = 0; k < sparkleTotal; k++) {
                sparkleIndices.push(Math.floor(Math.random() * activeCount));
            }
            
            const spColors = sparkleSystem.geometry.attributes.color.array;
            
            // T·ªëi ∆∞u v√≤ng l·∫∑p
            const validIndicesLength = validIndices.length;
            for (let i = 0; i < activeCount; i++) {
                const idxIndex = Math.floor((i * validIndicesLength) / activeCount);
                const idx = validIndices[idxIndex];
                const px = (idx/4) % w;
                const py = Math.floor((idx/4) / w);
                
                const tx = (px / w - 0.5) * spread;
                const ty = -(py / h - 0.5) * spread * imgAspect;
                const tz = (Math.random() - 0.5) * 2;
                
                const i3 = i * 3;
                pTarget[i3] = tx;
                pTarget[i3 + 1] = ty;
                pTarget[i3 + 2] = tz;
                
                const ang = Math.random() * Math.PI * 2;
                const rad = spread * (1.5 + Math.random());
                
                pScatter[i3] = Math.cos(ang) * rad;
                pScatter[i3 + 1] = Math.sin(ang) * rad;
                pScatter[i3 + 2] = (Math.random() - 0.5) * 100;
                
                if (appState === 'FOX' && id === 1 && currentOpacity === 1.0) {
                    pCurrent[i3] = tx;
                    pCurrent[i3 + 1] = ty;
                    pCurrent[i3 + 2] = tz;
                }
                
                const r = data[idx], g = data[idx + 1], b = data[idx + 2];
                _tempColor.setRGB(r/255, g/255, b/255).lerp(_targetColor, 0.1);
                instancedMesh.setColorAt(i, _tempColor);
            }
            
            // T·ªëi ∆∞u sparkle colors
            for(let k = 0; k < sparkleTotal; k++) {
                const particleIndex = sparkleIndices[k];
                const idxIndex = Math.floor((particleIndex * validIndicesLength) / activeCount);
                const idx = validIndices[idxIndex];
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];
                
                const k3 = k * 3;
                spColors[k3] = Math.min(1, (r/255) * 1.3 + 0.2);
                spColors[k3 + 1] = Math.min(1, (g/255) * 1.3 + 0.2);
                spColors[k3 + 2] = Math.min(1, (b/255) * 1.3 + 0.2);
            }
            
            sparkleSystem.geometry.attributes.color.needsUpdate = true;
            instancedMesh.instanceMatrix.needsUpdate = true;
            instancedMesh.instanceColor.needsUpdate = true;
        }

        // ========== VISUAL EFFECTS T·ªêI ∆ØU ==========
        function setupSparkles() {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.sparkleCount * 3);
            const colors = new Float32Array(CONFIG.sparkleCount * 3);
            
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const tex = createCircleTexture();
            const mat = new THREE.PointsMaterial({ 
                size: 0.6,
                transparent: true,
                opacity: 1.0,
                map: tex,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            sparkleSystem = new THREE.Points(geom, mat);
            mainGroup.add(sparkleSystem);
        }

        function setupAuraRing() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(AURA_COUNT * 3);
            const baseRadius = 45;
            const ringThickness = 8;
            
            for (let i = 0; i < AURA_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = baseRadius + (Math.random() - 0.5) * ringThickness;
                const i3 = i * 3;
                positions[i3] = r * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(theta) * 0.7;
                positions[i3 + 2] = (Math.random() - 0.5) * 20;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const tex = createCircleTexture();
            const material = new THREE.PointsMaterial({
                color: 0xffaadd,
                size: 0.8,
                map: tex,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            auraRingSystem = new THREE.Points(geometry, material);
            scene.add(auraRingSystem);
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 16; // GI·∫¢M t·ª´ 32 xu·ªëng 16
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(8, 8, 0, 8, 8, 8);
            
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.8)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 16, 16);
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function setupFloatingStars() {
            const starCount = 60; // GI·∫¢M t·ª´ 100 xu·ªëng 60
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(starCount * 3);
            const spd = new Float32Array(starCount);
            
            for(let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                pos[i3] = (Math.random() - 0.5) * 200; // GI·∫¢M range
                pos[i3 + 1] = (Math.random() - 0.5) * 150;
                pos[i3 + 2] = (Math.random() - 0.5) * 80 - 50;
                spd[i] = 0.2 + Math.random() * 0.5;
            }
            
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geom.setAttribute('speed', new THREE.BufferAttribute(spd, 1));
            
            const mat = new THREE.PointsMaterial({
                color: 0xffccdd,
                size: 0.8, // GI·∫¢M size
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createCircleTexture()
            });
            
            starSystem = new THREE.Points(geom, mat);
            scene.add(starSystem);
        }

        function setupWhiteStars() {
            const count = 100; // GI·∫¢M t·ª´ 150 xu·ªëng 100
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const spd = new Float32Array(count);
            
            for(let i = 0; i < count; i++) {
                const i3 = i * 3;
                pos[i3] = (Math.random() - 0.5) * 250; // GI·∫¢M range
                pos[i3 + 1] = (Math.random() - 0.5) * 200;
                pos[i3 + 2] = (Math.random() - 0.5) * 120 - 20;
                spd[i] = 0.1 + Math.random() * 0.3;
            }
            
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geom.setAttribute('speed', new THREE.BufferAttribute(spd, 1));
            
            const mat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.4, // GI·∫¢M size
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createCircleTexture()
            });
            
            whiteStarSystem = new THREE.Points(geom, mat);
            scene.add(whiteStarSystem);
        }

        function setupGlitter() {
            const c = 80; // GI·∫¢M t·ª´ 150 xu·ªëng 80
            const g = new THREE.BufferGeometry();
            const p = new Float32Array(c * 3);
            const s = new Float32Array(c);
            
            for(let i = 0; i < c; i++) {
                const i3 = i * 3;
                p[i3] = (Math.random() - 0.5) * 150; // GI·∫¢M range
                p[i3 + 1] = (Math.random() - 0.5) * 80;
                p[i3 + 2] = (Math.random() - 0.5) * 40 + 20;
                s[i] = 0.5 + Math.random() * 1.5;
            }
            
            g.setAttribute('position', new THREE.BufferAttribute(p, 3));
            g.setAttribute('speed', new THREE.BufferAttribute(s, 1));
            
            const m = new THREE.PointsMaterial({
                color: 0xffb7c5,
                size: 1.2, // GI·∫¢M size
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createCircleTexture()
            });
            
            glitterSystem = new THREE.Points(g, m);
            scene.add(glitterSystem);
        }

        // ========== UI ELEMENTS T·ªêI ∆ØU ==========
        function setupSlideshow() {
            slideshowGroup = new THREE.Group();
            slideshowGroup.position.z = 25;
            scene.add(slideshowGroup);
            
            const textureLoader = new THREE.TextureLoader();
            const photoSize = 22;
            const cardWidth = 24;
            const cardHeight = 28;
            
            totalSlideWidth = SLIDE_IMAGES.length * CONFIG.slideGap;
            let startX = -(totalSlideWidth / 2) + (CONFIG.slideGap / 2);
            
            // Load ·∫£nh slideshow v·ªõi ƒë·ªô ∆∞u ti√™n th·∫•p h∆°n
            setTimeout(() => {
                SLIDE_IMAGES.forEach((path, index) => {
                    textureLoader.load(path, (tex) => {
                        // T·ªëi ∆∞u texture
                        tex.generateMipmaps = false;
                        tex.minFilter = THREE.LinearFilter;
                        
                        const cardGeo = new THREE.PlaneGeometry(cardWidth, cardHeight);
                        const cardMat = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0
                        });
                        const cardMesh = new THREE.Mesh(cardGeo, cardMat);
                        
                        const imgAspect = tex.image.width / tex.image.height;
                        if (imgAspect > 1) {
                            tex.repeat.set(1 / imgAspect, 1);
                            tex.offset.x = (1 - (1/imgAspect)) / 2;
                        } else {
                            tex.repeat.set(1, imgAspect);
                            tex.offset.y = (1 - imgAspect) / 2;
                        }
                        
                        const photoGeo = new THREE.PlaneGeometry(photoSize, photoSize);
                        const photoMat = new THREE.MeshBasicMaterial({
                            map: tex,
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0,
                            side: THREE.DoubleSide
                        });
                        const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                        
                        photoMesh.position.z = 0.1;
                        photoMesh.position.y = 1.5;
                        
                        const polaroid = new THREE.Group();
                        polaroid.add(cardMesh);
                        polaroid.add(photoMesh);
                        polaroid.position.set(startX + (index * CONFIG.slideGap), 0, 0);
                        polaroid.rotation.z = (Math.random() - 0.5) * 0.2;
                        polaroid.userData = { materials: [cardMat, photoMat] };
                        
                        slides.push(polaroid);
                        slideshowGroup.add(polaroid);
                    });
                });
            }, 1000); // Delay ƒë·ªÉ ∆∞u ti√™n c√°c ph·∫ßn kh√°c
        }

        function setupMessageMesh() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(IMG_LETTER, (tex) => {
                tex.generateMipmaps = false;
                tex.minFilter = THREE.LinearFilter;
                
                const aspect = tex.image.width / tex.image.height;
                const h = 40;
                const w = h * aspect;
                
                const geo = new THREE.PlaneGeometry(w, h);
                const mat = new THREE.MeshBasicMaterial({
                    map: tex,
                    transparent: true,
                    opacity: 1,
                    side: THREE.DoubleSide,
                    depthTest: false,
                    depthWrite: false
                });
                
                messageMesh = new THREE.Mesh(geo, mat);
                messageMesh.renderOrder = 999;
                messageMesh.position.set(0, -60, 25);
                messageMesh.scale.set(0,0,0);
                scene.add(messageMesh);
            }, undefined, (err) => console.log("Error loading message texture:", err));
        }

        function setupSinglePhoto() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(IMG_PHOTO_SINGLE, (tex) => {
                tex.generateMipmaps = false;
                tex.minFilter = THREE.LinearFilter;
                
                const aspect = tex.image.width / tex.image.height;
                const h = 40;
                const w = h * aspect;
                
                const geo = new THREE.PlaneGeometry(w, h);
                const mat = new THREE.MeshBasicMaterial({
                    map: tex,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                
                singlePhotoMesh = new THREE.Mesh(geo, mat);
                singlePhotoMesh.position.set(0, 0, 30);
                scene.add(singlePhotoMesh);
            }, undefined, (err) => console.log("Error loading photo texture:", err));
        }

        // ========== ANIMATION LOOP T·ªêI ∆ØU ==========
        function animate() {
            if (!isAnimating) return;
            
            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            
            // Ki·ªÉm so√°t FPS
            if (deltaTime < FRAME_TIME) {
                requestAnimationFrame(animate);
                return;
            }
            
            lastFrameTime = now - (deltaTime % FRAME_TIME);
            
            const dt = Math.min(deltaTime / 1000, 0.033); // Gi·ªõi h·∫°n delta time
            
            // C·∫≠p nh·∫≠t FPS counter
            frameCount++;
            if (now - lastFpsTime >= 1000) {
                currentFps = Math.round((frameCount * 1000) / (now - lastFpsTime));
                frameCount = 0;
                lastFpsTime = now;
                
                // T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh quality d·ª±a tr√™n FPS
                if (currentFps < 30) {
                    reduceQuality();
                } else if (currentFps > 50) {
                    increaseQuality();
                }
            }
            
            // Audio visualization
            let musicBass = 0;
            if (isAudioSetup && audioAnalyser && audioDataArray) {
                drawVisualizer();
                let sum = 0;
                for (let i = 0; i < 10; i++) { // Ch·ªâ l·∫•y 10 frequency bins
                    sum += audioDataArray[i];
                }
                musicBass = (sum / 10) / 255;
            }
            
            // Update c√°c h·ªá th·ªëng v·ªõi ƒë·ªô ∆∞u ti√™n kh√°c nhau
            updateParticles(dt, musicBass);
            
            // Ch·ªâ update glitter v√† stars m·ªói 2 frame
            if (frameCount % 2 === 0) {
                updateGlitter(dt);
                updateFloatingStars(dt);
                updateAuraRing(dt, musicBass);
            }
            
            // Render
            composer.render();
            
            requestAnimationFrame(animate);
        }

        // ========== QUALITY ADAPTATION ==========
        let currentQuality = 'high';
        
        function reduceQuality() {
            if (currentQuality === 'low') return;
            
            currentQuality = 'medium';
            console.log('Reducing quality to medium');
            
            // Gi·∫£m s·ªë l∆∞·ª£ng particles
            if (count > 4000) {
                instancedMesh.count = Math.floor(count * 0.7);
            }
            
            // T·∫Øt bloom
            bloomPass.enabled = false;
            
            // Gi·∫£m sparkle count
            if (sparkleSystem) {
                sparkleSystem.visible = false;
            }
        }
        
        function increaseQuality() {
            if (currentQuality === 'high') return;
            
            currentQuality = 'high';
            console.log('Increasing quality to high');
            
            // Kh√¥i ph·ª•c particles
            instancedMesh.count = count;
            
            // B·∫≠t bloom
            bloomPass.enabled = true;
            
            // B·∫≠t sparkle
            if (sparkleSystem) {
                sparkleSystem.visible = true;
            }
        }

        function updateParticles(dt, musicBass = 0) {
            if (!instancedMesh) return;
            
            const time = clock.getElapsedTime();
            let targetOpacity = 1.0;
            let targetBloom = 0.0;
            let moveTarget = 'TARGET';
            
            // T·ªëi ∆∞u smooth parallax
            smoothedParallax.x += (handParallax.x - smoothedParallax.x) * 3.0 * dt;
            smoothedParallax.y += (handParallax.y - smoothedParallax.y) * 3.0 * dt;
            
            const tiltX = smoothedParallax.y * 0.3;
            const tiltY = smoothedParallax.x * 0.3;
            const breathingY = Math.sin(time * 0.5) * 0.1;

            if (isLoadingDelay) {
                loadingDelayTime -= dt;
                if (loadingDelayTime <= 0) {
                    isLoadingDelay = false;
                    setGuide("N·∫Øm tay <span class='highlight'>‚úä</span> ƒë·ªÉ bi·∫øn h√¨nh, ho·∫∑c gh√©p Tim ü´∂");
                }
            }
            
            const h1 = document.getElementById('main-title');
            if(h1) {
                if(appState === 'READING_LETTER') h1.classList.add('hide-title');
                else h1.classList.remove('hide-title');
            }

            // State management - t·ªëi ∆∞u
            switch (appState) {
                case 'FOX':
                    targetOpacity = 1.0;
                    targetBloom = 0.0;
                    if (isLoadingDelay) setGuide("Loading...");
                    break;
                    
                case 'TRANSITION_TO_PEN':
                    targetOpacity = 0.0;
                    targetBloom = 4.0;
                    moveTarget = 'SCATTER';
                    if (currentOpacity < 0.05) {
                        useImageData(2);
                        mainGroup.rotation.set(0,0,0);
                        appState = 'REASSEMBLING_PEN';
                    }
                    break;
                    
                case 'REASSEMBLING_PEN':
                    targetOpacity = 1.0;
                    targetBloom = 0.0;
                    moveTarget = 'TARGET';
                    if (currentOpacity > 0.95) appState = 'PEN';
                    break;
                    
                case 'PEN':
                    targetOpacity = 1.0;
                    targetBloom = 0.0;
                    setGuide("Ch·ª•m tay <span class='highlight'>ü§å</span> m·ªü th∆∞, ho·∫∑c X√≤e tay ƒë·ªÉ quay l·∫°i");
                    break;
                    
                case 'READING_LETTER':
                    targetOpacity = 0.4;
                    targetBloom = 0.3;
                    setGuide("X√≤e tay <span class='highlight'>‚úã</span> ƒë·ªÉ ƒë√≥ng th∆∞");
                    break;
                    
                case 'BACK_TO_FOX':
                    targetOpacity = 0.0;
                    targetBloom = 4.0;
                    moveTarget = 'SCATTER';
                    if (currentOpacity < 0.05) {
                        useImageData(1);
                        mainGroup.rotation.set(0,0,0);
                        appState = 'REASSEMBLING_FOX';
                    }
                    break;
                    
                case 'REASSEMBLING_FOX':
                    targetOpacity = 1.0;
                    targetBloom = 0.0;
                    moveTarget = 'TARGET';
                    if (currentOpacity > 0.95) {
                        appState = 'FOX';
                        updateStatus("Ready");
                        isLoadingDelay = true;
                        loadingDelayTime = 1.0; // GI·∫¢M t·ª´ 2.0 xu·ªëng 1.0
                        setGuide("Ready...");
                        interactionLock = Date.now() + 1000; // GI·∫¢M t·ª´ 2000 xu·ªëng 1000
                    }
                    break;
                    
                case 'SLIDESHOW':
                    targetOpacity = 0.0;
                    targetBloom = 0.0;
                    moveTarget = 'SCATTER';
                    setGuide("X√≤e tay <span class='highlight'>‚úã</span> ƒë·ªÉ quay l·∫°i.");
                    break;
                    
                case 'VIEW_PHOTO':
                    targetOpacity = 0.2;
                    targetBloom = 0.1;
                    setGuide("X√≤e tay <span class='highlight'>‚úã</span> ƒë·ªÉ quay l·∫°i.");
                    break;
            }

            // T·ªëi ∆∞u animation updates
            if (appState === 'VIEW_PHOTO') {
                animSinglePhoto.opacity += (1.0 - animSinglePhoto.opacity) * 2.0 * dt;
                animSinglePhoto.scale += (1.0 - animSinglePhoto.scale) * 2.0 * dt;
            } else {
                animSinglePhoto.opacity *= 0.9; // Thay v√¨ interpolation ch·∫≠m
                animSinglePhoto.scale *= 0.9;
            }
            
            if(singlePhotoMesh) {
                singlePhotoMesh.material.opacity = animSinglePhoto.opacity;
                singlePhotoMesh.scale.setScalar(animSinglePhoto.scale);
                singlePhotoMesh.rotation.x = tiltX * 0.5;
                singlePhotoMesh.rotation.y = tiltY * 0.5;
            }

            // Letter animation t·ªëi ∆∞u
            if (appState === 'READING_LETTER') {
                animLetter.pScale = 0.1;
                animLetter.pY = -40;
                animLetter.scale = 1.0;
                animLetter.y = 0;
            } else {
                animLetter.pScale = 1.0;
                animLetter.pY = 0;
                animLetter.scale = 0;
                animLetter.y = -60;
            }

            // Slideshow t·ªëi ∆∞u
            if (appState === 'SLIDESHOW') {
                animSlide.opacity = 1.0;
                const boundary = (totalSlideWidth / 2) + CONFIG.slideGap;
                
                slides.forEach((group, idx) => {
                    group.position.x += CONFIG.slideSpeed * dt;
                    if (group.position.x > boundary) {
                        group.position.x -= totalSlideWidth;
                    }
                    
                    group.userData.materials.forEach(m => m.opacity = 1);
                    group.rotation.y = tiltY * 0.3;
                });
                
                slideshowGroup.rotation.x = tiltX * 0.3;
            } else {
                animSlide.opacity = 0;
                slides.forEach(group => {
                    group.userData.materials.forEach(m => m.opacity = 0);
                });
            }

            // Update transforms
            mainGroup.scale.setScalar(animLetter.pScale);
            mainGroup.position.y = animLetter.pY;
            
            if (appState === 'TRANSITION_TO_PEN' || appState === 'BACK_TO_FOX') {
                mainGroup.rotation.z += 2.0 * dt;
                mainGroup.rotation.x = 0;
                mainGroup.rotation.y = 0;
            } else {
                mainGroup.rotation.x = tiltX;
                mainGroup.rotation.y = tiltY + breathingY;
                mainGroup.rotation.z = 0;
            }
            
            if(messageMesh) {
                messageMesh.scale.setScalar(animLetter.scale);
                messageMesh.position.y = animLetter.y;
                messageMesh.rotation.x = tiltX * 0.5;
                messageMesh.rotation.y = tiltY * 0.5;
            }

            // Bloom effect t·ªëi ∆∞u
            let beatBloom = targetBloom + (musicBass * 1.5);
            currentBloomStrength = beatBloom; // Thay v√¨ interpolation ch·∫≠m
            bloomPass.strength = currentBloomStrength;

            // Opacity t·ªëi ∆∞u
            if (['TRANSITION_TO_PEN', 'BACK_TO_FOX', 'SLIDESHOW', 'VIEW_PHOTO'].includes(appState)) {
                currentOpacity -= CONFIG.fadeSpeed * dt;
            } else if (['REASSEMBLING_PEN', 'REASSEMBLING_FOX'].includes(appState)) {
                currentOpacity += CONFIG.fadeSpeed * dt;
            }
            
            currentOpacity = Math.max(0, Math.min(1, currentOpacity));
            instancedMesh.material.opacity = currentOpacity;

            // T·ªëi ∆∞u particle updates
            const factor = (moveTarget === 'SCATTER' ? 1.0 : 2.5) * dt;
            const isIdle = (appState === 'FOX' || appState === 'PEN');
            const isScatter = (moveTarget === 'SCATTER');
            
            // S·ª≠ d·ª•ng while loop nhanh h∆°n
            let i = 0;
            while (i < count) {
                const i3 = i * 3;
                let tx, ty, tz;
                
                if (isScatter) {
                    tx = pScatter[i3];
                    ty = pScatter[i3 + 1];
                    tz = pScatter[i3 + 2];
                } else {
                    tx = pTarget[i3];
                    ty = pTarget[i3 + 1];
                    tz = pTarget[i3 + 2];
                }
                
                let cx = pCurrent[i3], cy = pCurrent[i3 + 1], cz = pCurrent[i3 + 2];
                cx += (tx - cx) * factor;
                cy += (ty - cy) * factor;
                cz += (tz - cz) * factor;
                
                if (isIdle) {
                    cx += Math.sin(time + i) * 0.003;
                    cy += Math.cos(time * 0.8 + i) * 0.003;
                }
                
                pCurrent[i3] = cx;
                pCurrent[i3 + 1] = cy;
                pCurrent[i3 + 2] = cz;
                
                dummy.position.set(cx, cy, cz);
                
                if (isIdle && musicBass > 0.05) {
                    const scaleEffect = 1.0 + (musicBass * 0.3);
                    dummy.scale.setScalar(scaleEffect);
                } else {
                    dummy.scale.setScalar(1.0);
                }
                
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
                i++;
            }
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            
            // Sparkles t·ªëi ∆∞u
            if(sparkleSystem && isIdle && currentOpacity > 0.5) {
                const spPos = sparkleSystem.geometry.attributes.position.array;
                
                for(let j = 0; j < sparkleIndices.length; j++) {
                    const idx = sparkleIndices[j] * 3;
                    const j3 = j * 3;
                    spPos[j3] = pCurrent[idx];
                    spPos[j3 + 1] = pCurrent[idx + 1];
                    spPos[j3 + 2] = pCurrent[idx + 2] + 2.0;
                }
                
                sparkleSystem.visible = true;
                sparkleSystem.material.opacity = 0.6 + (musicBass * 0.5);
                sparkleSystem.geometry.attributes.position.needsUpdate = true;
            } else if (sparkleSystem) {
                sparkleSystem.visible = false;
            }
        }

        function updateGlitter(dt) {
            if(!glitterSystem) return;
            
            const p = glitterSystem.geometry.attributes.position.array;
            const s = glitterSystem.geometry.attributes.speed.array;
            const time = clock.elapsedTime;
            
            for(let i = 0; i < p.length/3; i++) {
                const i3 = i * 3;
                p[i3 + 1] += s[i] * dt;
                
                if(p[i3 + 1] > 60) {
                    p[i3 + 1] = -60;
                    p[i3] = (Math.random() - 0.5) * 150;
                }
            }
            
            glitterSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updateFloatingStars(dt) {
            if(starSystem) {
                const p = starSystem.geometry.attributes.position.array;
                const s = starSystem.geometry.attributes.speed.array;
                
                for(let i = 0; i < p.length/3; i++) {
                    const i3 = i * 3;
                    p[i3 + 1] += s[i] * dt * 5.0;
                    
                    if(p[i3 + 1] > 100) {
                        p[i3 + 1] = -100;
                        p[i3] = (Math.random() - 0.5) * 200;
                    }
                }
                
                starSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            if(whiteStarSystem) {
                const p = whiteStarSystem.geometry.attributes.position.array;
                const s = whiteStarSystem.geometry.attributes.speed.array;
                
                for(let i = 0; i < p.length/3; i++) {
                    const i3 = i * 3;
                    p[i3 + 1] += s[i] * dt * 3.0;
                    
                    if(p[i3 + 1] > 120) {
                        p[i3 + 1] = -120;
                        p[i3] = (Math.random() - 0.5) * 250;
                    }
                }
                
                whiteStarSystem.geometry.attributes.position.needsUpdate = true;
            }
        }

        function updateAuraRing(dt, bass) {
            if (!auraRingSystem) return;
            
            auraRingSystem.rotation.z += dt * 0.1;
            auraRingSystem.rotation.y = Math.sin(clock.elapsedTime * 0.5) * 0.1;
            
            const targetScale = 1.0 + (bass * 1.0);
            auraRingSystem.scale.setScalar(targetScale);
            
            const targetOpacity = 0.3 + (bass * 2.0);
            auraRingSystem.material.opacity = Math.min(1.0, targetOpacity);
        }

        // ========== AUDIO T·ªêI ∆ØU ==========
        function setupAudioSystem() {
            if (isAudioSetup) return;
            
            const audioElement = document.getElementById('audio-bg');
            if (!audioElement) return;
            
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                
                // Resume context khi user t∆∞∆°ng t√°c
                document.addEventListener('click', () => {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                }, { once: true });
                
                audioSource = audioContext.createMediaElementSource(audioElement);
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 128; // GI·∫¢M t·ª´ 256 xu·ªëng 128
                audioAnalyser.smoothingTimeConstant = 0.8;
                
                audioSource.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);
                
                audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                isAudioSetup = true;
            } catch (e) {
                console.warn("Web Audio API not supported:", e);
            }
        }

        function initVisualizer2D() {
            visualizerCanvas = document.getElementById('visualizer-canvas');
            if(visualizerCanvas) {
                visualizerCtx = visualizerCanvas.getContext('2d', { alpha: false }); // T·∫Øt alpha cho performance
                const updateSize = () => {
                    visualizerCanvas.width = visualizerCanvas.offsetWidth;
                    visualizerCanvas.height = visualizerCanvas.offsetHeight;
                };
                updateSize();
                window.addEventListener('resize', updateSize);
            }
        }

        function drawVisualizer() {
            if (!isAudioSetup || !visualizerCtx || !visualizerCanvas) return;
            
            const width = visualizerCanvas.width;
            const height = visualizerCanvas.height;
            const ctx = visualizerCtx;
            
            // Clear v·ªõi hi·ªáu nƒÉng cao
            ctx.clearRect(0, 0, width, height);
            
            audioAnalyser.getByteFrequencyData(audioDataArray);
            const barWidth = (width / 32) * 1.5; // Ch·ªâ v·∫Ω 32 bars thay v√¨ t·∫•t c·∫£
            let x = 0;
            const centerY = height / 2;
            
            for (let i = 0; i < 32; i+=2) {
                const barHeight = (audioDataArray[i] / 255) * height * 0.6;
                const r = 255;
                const g = 150 + (i * 3);
                const b = 200;
                
                ctx.fillStyle = `rgb(${r},${g},${b})`; // Kh√¥ng d√πng rgba ƒë·ªÉ tƒÉng performance
                ctx.fillRect(width/2 + x, centerY - barHeight/2, barWidth, barHeight);
                ctx.fillRect(width/2 - x - barWidth, centerY - barHeight/2, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        // ========== HAND TRACKING T·ªêI ∆ØU ==========
        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://unpkg.com/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2
                });
                
                video = document.getElementById("webcam");
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 320 }, // GI·∫¢M resolution
                        height: { ideal: 240 },
                        frameRate: { ideal: 15 } // GI·∫¢M frame rate
                    }
                });
                
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            } catch (error) {
                console.error("MediaPipe initialization failed:", error);
                updateStatus("Camera error - Using mouse control");
                setupMouseControl();
            }
        }

        // Fallback mouse control
        function setupMouseControl() {
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth - 0.5) * 2.5;
                mouseY = (e.clientY / window.innerHeight - 0.5) * 2.5;
                
                handParallax.x = mouseX;
                handParallax.y = mouseY;
            });
            
            // Simulate gestures with keyboard
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'f': // Fist
                        changeState('TRANSITION_TO_PEN');
                        break;
                    case 'p': // Pinch
                        changeState('READING_LETTER');
                        break;
                    case 'o': // Open
                        changeState('BACK_TO_FOX');
                        break;
                    case 'h': // Heart
                        changeState('SLIDESHOW');
                        break;
                }
            });
            
            setGuide("Use mouse to move, keys: F=Fist, P=Pinch, O=Open, H=Heart");
        }

        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime && video.readyState >= 2) {
                lastVideoTime = video.currentTime;
                
                if (handLandmarker && isFoxLoaded && isPenLoaded) {
                    let startTimeMs = performance.now();
                    const result = handLandmarker.detectForVideo(video, startTimeMs);
                    
                    if (result.landmarks && result.landmarks.length > 0) {
                        // Calculate hand center - t·ªëi ∆∞u
                        let centerX = 0, centerY = 0;
                        const firstLandmark = result.landmarks[0];
                        centerX += firstLandmark[0].x;
                        centerY += firstLandmark[0].y;
                        
                        const targetX = (0.5 - centerX) * 2.5;
                        const targetY = (0.5 - centerY) * 2.5;
                        
                        handParallax.x = targetX; // Thay v√¨ smooth interpolation
                        handParallax.y = targetY;
                        
                        // Detect gestures - t·ªëi ∆∞u
                        const lm = result.landmarks[0];
                        const thumbTip = lm[4];
                        const indexTip = lm[8];
                        
                        const pinchDist = Math.abs(indexTip.x - thumbTip.x) + Math.abs(indexTip.y - thumbTip.y); // T√≠nh nhanh h∆°n
                        
                        // Simple gesture detection
                        const isPinch = pinchDist < 0.06;
                        const isFist = lm[8].y > lm[0].y && lm[12].y > lm[0].y; // Simple check
                        const isOpen = !isPinch && !isFist;
                        
                        // Update gesture buffers
                        if(isPinch) gestureBuffer.pinch = Math.min(gestureBuffer.pinch + 1, CONFIG.gestureThreshold);
                        else gestureBuffer.pinch = 0;
                        
                        if(isOpen) gestureBuffer.open = Math.min(gestureBuffer.open + 1, CONFIG.gestureThreshold);
                        else gestureBuffer.open = 0;
                        
                        if(isFist) gestureBuffer.fist = Math.min(gestureBuffer.fist + 1, CONFIG.gestureThreshold);
                        else gestureBuffer.fist = 0;
                        
                        // State transitions
                        if (Date.now() > interactionLock) {
                            if (appState === 'FOX') {
                                if (gestureBuffer.fist >= CONFIG.gestureThreshold) changeState('TRANSITION_TO_PEN');
                            }
                            else if (appState === 'PEN') {
                                if (gestureBuffer.pinch >= CONFIG.gestureThreshold) changeState('READING_LETTER');
                                else if (gestureBuffer.open >= CONFIG.gestureThreshold) changeState('BACK_TO_FOX');
                            }
                            else if (['READING_LETTER', 'SLIDESHOW', 'VIEW_PHOTO'].includes(appState)) {
                                if (gestureBuffer.open >= CONFIG.gestureThreshold) changeState('BACK_TO_FOX');
                            }
                        }
                    } else {
                        handParallax.x = 0;
                        handParallax.y = 0;
                    }
                }
            }
            
            // Throttle hand tracking
            setTimeout(() => {
                requestAnimationFrame(predictWebcam);
            }, 1000 / 15); // 15 FPS cho hand tracking
        }

        // ========== STATE MANAGEMENT T·ªêI ∆ØU ==========
        function stopAllAudio() {
            const a1 = document.getElementById('audio-bg');
            const a2 = document.getElementById('audio-letter');
            
            if (a1) {
                a1.pause();
                a1.currentTime = 0;
            }
            
            if (a2) {
                a2.pause();
                a2.currentTime = 0;
            }
        }

        function changeState(newState) {
            const now = Date.now();
            if (now - lastActionTime < 500) return; // GI·∫¢M t·ª´ 1000 xu·ªëng 500ms
            if (appState === newState) return;
            
            lastActionTime = now;
            
            switch(newState) {
                case 'TRANSITION_TO_PEN':
                    stopAllAudio();
                    const a1 = document.getElementById('audio-bg');
                    if(a1) {
                        if(!isAudioSetup) setupAudioSystem();
                        a1.play().catch(e => console.log("Audio blocked:", e));
                    }
                    updateStatus("Transforming...");
                    break;
                    
                case 'READING_LETTER':
                    stopAllAudio();
                    const a2 = document.getElementById('audio-letter');
                    if(a2) a2.play().catch(e => console.log("Audio blocked:", e));
                    updateStatus("Opening...");
                    break;
                    
                case 'BACK_TO_FOX':
                    stopAllAudio();
                    updateStatus("Returning...");
                    break;
                    
                case 'SLIDESHOW':
                    updateStatus("Memories ‚ù§Ô∏è");
                    break;
                    
                case 'VIEW_PHOTO':
                    updateStatus("Photo!");
                    break;
            }
            
            appState = newState;
        }

        // ========== UI FUNCTIONS ==========
        function setGuide(txt) {
            const el = document.getElementById('guide-text');
            if(el) el.innerHTML = txt;
        }

        function updateStatus(msg) {
            const el = document.getElementById('status-bar');
            if(el) el.innerText = msg;
        }

        function setupEvents() {
            const resizeHandler = () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                bloomPass.resolution.set(window.innerWidth/8, window.innerHeight/8);
            };
            
            window.addEventListener('resize', resizeHandler);
            
            // Debounce resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(resizeHandler, 250);
            });
        }

        // ========== START APPLICATION ==========
        // Kh·ªüi ƒë·ªông ngay khi DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
